La experiencia del desarrollador de .NET MAUI generalmente implica crear una interfaz de usuario en XAML y luego agregar codigo subyacente que opera
en la interfaz de usuario. Pueden surgir problemas de mantenimiento complejos a medida que se modifican las aplicaciones y crecen en tamaño y alcance. 
Estos problemas incluyen al acoplamiento estrecho entre los controles de la interfaz de usuario y la logica empresarial, lo que aumenta el costo de realizar
modificaciones en la interfaz de usuario y la dificultad de realizar pruebas unitarias de dicho codigo.

El patron MVVM ayuda a separar claramente la logica de presentacion y de negocios de una aplicacion de su interfaz de usuario (UI). Mantener una separacion clara entre
la logica de la aplicacion y la UI ayuda a abordar numerosos problemas de desarrollo y hace que una aplicacion sea mas facil de probar, mantener y desarrollar. Tambien puede
mejorar significativamente las oportunidades de reutilizacion de codigo y permtite que los desarrolladores y los diseñadores de UI colaboren mas facilmente al desarrollar sus 
respectivas partes de una aplicacion.

--------------------------------

The .NET MAUI developer experience typically involves creating a user interface in XAML, and then adding code-behind that operates on the user interface. Complex maintenance issues
can arise as apps are modified and grow in size and scope. These issues include the tigt coupling between the UI controls and the buisness logic, wich increases the cost of making UI 
modifications, and the difficulty of unit testing such code.

The MVVM pattern helps cleanly separate an application's business and presentation logic from its user interface (UI). Maintaining a clean separation between application logic and the UI helps
address numerous development issues and makes and application easier to test, maintain, and envolve. It can also significantly improve code re-use opportunities and allows developers and UI designers
to collaborate more easily when developing their respective parts of an app.

------------------------

El patron MVVM

El patron MVVM consta de tres componentes principales: el modelo, la vista y el modelo de vista. Cada uno cumple uno cumple una funcion especifica.

Ademas de comprender las responsabilidades de cada componente, tambien es importante comprender como interactuan. En un nivel alto, la vista "conoce" el modelo de vista y el modelo de vista "conoce" el modelo,
pero el modelo no conoce el modelo de vista y el modelo de vista no conoce la vista. Por lo tanto, el modelo de vista aisla la vista del modelo y permite que el modelo evolucione independientemente de la vista.

Los beneficios de utilizar el patron MVVM son los siguientes:
*** Si una implementacion de modelo existente encapsula la logica empresarial existente, puede resultar dificil o riesgoso cambiarla. En este escenario, el modelo de vista actua como un adaptador para las clases del modelo
y evita que se realicen cambios importantes en el codigo del modelo.

*** Los desarrolladores pueden crear pruebas unitarias para el modelo de vista y el modelo sin utilizar la vista. Las pruebas unitarias para el modelo de vista pueden ejercer exactamente la misma funcionalidad que utiliza la vista.

*** La interfa de usuario de la aplicacion de puede rediseñar sin modificar el modelo de vista ni el codigo del modelo, siempre que la vista se implemente completamente en XAML o C#. Por lo tanto, en una nueva version de la vista deberia
funcionar con el modelo de vista existente.

*** Los diseñadores y desarrolladores pueden trabajar de forma independiente y simultanea en sus componentes durante el desarrollo. Los diseñadores pueden centrarse en la vista, mientras que los desarrolladores pueden trabajar en el modeo de vista
y los componentes del modelo.

La clave par ausar MVVM de manera efizaz radica en comprender como factorizar el codigo de la aplicacion en las clases correctas y como interactuan las clases.

--------------------------------------

The MVVM pattern

There are three core components in the MVVM pattern: the model, the view, and the view model. Each servers a distinct purpose. The diagram belows shows the relationships between the threen components.

In addition to understanding the responsabilities of each component, it's also imporntant to understand how they interact. At a high level, the view "knows about" the view model, and the view model "knows about" the mode, but the
model is unaware of the view model, and the view model is unaware of the view. Therefore, the view model isolates the view from the model, and allows the model to envolve independently of the view.

The benefits of using the MVVM pattern are as follows:

***If an existing model implementation encapsulates existing bsiness logic, it can be difficult or risky to change it. In this scenario, the view model acts as and adapter for the model classes and prevents you from making major changes to the model code.

***Developers can create unit tests for the view model and the model, without using the view. The unit test for the view model can exercise exactly the same functionality as used by the view.

***The app UI can be redesigned without touching the view model and model code, provided that the view is implemented entirely in XAML or C#. Therefore, a new version of the view should work with the existing view model.

***Designers and developers can work independently and concurrently on their components during development. Designers can focus on the view, while developers can work on the view model and model components.

The key to using MVVM effectively lies in understanding how to factor app code into the correct classes and how the classes interact.

View

The view is reponsible for defining the structure, layout, and appearance of what the user sees on screen. Ideally, each view is defined in XAML, with a limtied code-behind that does not contain business logic. However, in some cases,
the code-behind migth contain UI logic that implements visual behavior that is difficult to express in XAML, such as animations.

In a .NET MAUI application, a vieew is typically a ContentPage- derived or ContentView- derived class. However, views can also be represented by a data template, wich specifies the UI elements to be used to visually represent an object 
when it's displayed. A data template as a vview does not have any code-behind, and is designed to bind to a specific view model type.

***Avoid enabling and disabling UI elements in the code-behind.

Ensure that the view models are responsible fro defining logical state changes that affect some aspects of the view's display, such as wheter a command is avialbe, or an indication that an operation is pending. Therefore, enable and disable UI
elements by binding to view model properties, rather than enabling and sisabling them in code-behind.

There are several options for executing code on the view model in response to interactions on the view, such as a button click on item selection. If a control supports commands, the control's Command property can be data-bound to an ICommand property on the view
model. When the control's command is invoked, the code in the view model will be executed.In object in the view and can listen for either a command to be invoked or the event to be raised. In response, the behavior can then invoke an ICommand on the view model
or a method on the view model.

------------------------------

Vista

La vista es responsable de definir la estructura, el diseño y la apariencia de lo que el usuario ve en la pantalla. Lo ideal es que cada vista se defina en XAML, con un codigo subyacente limitado que no contiene logica empresarial. Sin embargo, en algunos casos,
el codigo subyacente puede contener logica de interfaz de usuario que implemente un comportamiento visual que es dificil de expresar en XAML, como animaciones.

En una aplicacion .NET MAUI, una vista es normalmente una clases ContentPage derivada o ContentView derivada de una vista. Sin embargo, las vistas tambien pueden representarse mediante una plantilla de datos,
que especifica los elementos de la interfaz de usuario que se utilizaran para representar visualmente un objecto cuando se muestre. Una plantilla de datos como vista no tiene ningun codigo subyacente y esta diseñada para vinculaese a un tipo de modelo de vista especifico.

***Eevite habilitar y deshabilitar elemetnos de la interfaz de usuario en el codigo subyacente.

Asegurese de que los modelos de vista sean responsables de definir los cambios de estado logicos que afectan algunos aspectos d ela visualizacion de la vista, como si un comando esta disponible o una indicacion de que una operacion esta pendiente. Por lo tanto, habilite y deshabilite
los elementos de la interfaz de usuario mediante la vinculacion a las propiedades del modelo de vista, en lugar de habilitarlos y deshabilitarlos en el codigo subyacente.

Existen varias opciones para ejecutar el codigo en el modelo de vista en respuesta a interacciones en la vista, como un clic en un boton o la seleccion de un elemento. Si un control admite comandos, la propiedad Command del control se puede vincular a una propiedad ICommand en el modelo de vista.
Cuando se invoca el comando del control, se ejecuta el codigo en el modelo de vista. Ademas de los comandos, los comportamientos se pueden adjuntar a un objeto en la vista y pueden escuchar si se invoca un comando o si genera un evento, el comportamietno puede invocar un ICommand en el modelo de vista o 
un metodo en el modelo de vista.

----------------------

ViewModel

The view model implements properties and commands to wich the view can data bind to, and notifies the view of any state changes trough change notification events. The properties and commands that the view model provides define the functionality to be offered by the UI, but the view determines how that
functionality is to be displayed.

****Keep the UI responsive with asynchronous operations.

Multi-platform apps should keep the UI thread unblocked to improve the user's perception of performance. Therefore, in the view model, use asyncrhonous methods for I/O operations and raise events to asyncrhonous notify views of property changes.

The view model is also responsible for coordinating the view's interactions with any model classes that are required. There typically a on-to many relationship between the view model and the model classes. The view model migth choose to expose model classes directly to them. In this case, 
the model classes will need to be designed to support data binding and change notification events.

Each view model provides data from a model in a form that the view can easily consume. Ti accinokish this, the view model sometimes performs data converison. Placing this data conversion in the view model is a good idea because it provides properties that the view can bind to. For exammple, 
the view model migth combine the values of two properties to make it easier to splay by the view.

*** Centralize data conversions in a conversion layer.

It's also possible to use converters as a separate data conversion layer that sits between the view model and the view. This can be necessary, for example, when data requires special formatting that the view model doesn't provide.

In order for the view model to participate in two-way data binding with the view, its properties must raise the PropertyChanged event. View model satisfy this requirement by implementing the INotifyPropertyChanged interface, and raising the PropertyCHanged event when a property is changed.

For collections, the view-friendly ObservableCollection<T> is provided. This collection implements collection changed notification, reileving the developer from having to implement the InotifyCollectionChanged interface on collections.

------------------------------------------

El modelo de vista implementa propiedades y comandos a los que la vista puede vincular datos y nitifica a la vista cualquier cambio de estado a traves de eventos de notificacion de cambios. Las propiedades y los comandos que proporciona el modelo de vista definen la funcionalidad que
ofrecera la interfaz de usuario, pero la vista determina como se mostrara esa funcionalidad.

*** Mantenga la interfaz de usuario responsiva con operaciones asincronicas.

Las aplicaciones multiplataforma deben mantener el hilo de la interfaz de usuario bloqueado para mejorar la percepcion del rendimiento del usuario. Por lo tantom en el modelo de vista, utilice metodos asincronicos para las operaciones de E/S y genere eventos para notificar asincronicamente
a las vistas sobre los cambios de propiedades.

El modelo de vista tambien es responsable de coordinar las interacciones de la vista con cualquier clase de modelo que sea necesaria. Normalmente, existe una relacion de uno a muchos entre el modeo de vista y las clases de modelo. El modelo de vista puede optar por exponer las clases de 
modelo directamente a la vista para que los controles de la vista puedan vincularse directamente a los datos de estas. En este caso, las clases de modelo deberan estar diseñadas para admitir la vinculacion de datos y los eventos de notificacion de cambios.

Cada modelo de vista proporciona datos de un modelo en un formato que la vista puede consumir facilmente. Para lograr esto, el modelo de vista a veces realizar una conversion de datos. Colocar esta conversion de datos en el modelo de vista es una buena idea porque proporciona propiedades a las
que la vista puede vincularse. Por ejemplo, el modelo de vista puede combinar los valores de dos propiedades para que sea mas facil de mostrar en la vista.

*** Centralice las conversiones de datos en una capa de conversion.

Tambien es posible utilizar convertidores como una capa de conversion de datos independiente que se ubica entre el modelo de vista y la vista. Esto puede ser necesario, por ejemplo, cuando los datos requieren un formato especial que el modelo de vista no proporciona.

Para que el modelo de vista participe en la vinculacion de datos bidireccional con la vista, sus propiedades deben generar el PorpertChanged evento. Los modelos de vista satisfacen este requisito implementando la INotifyPropertyChanged interfaz y generando el PropertyChanged evento cuando se modifica
una propiedad.

Para las colecciones, se proporciona una interfaz facil de usar ObservableCollection<T>. Esta coleccion implementa la notificacion de cambios en la coleccion, lo que evita que el desarrollador tenga que implementar la INotifyCollectionChanged interfaz en las colecciones.

-------------------

Model

Model classes are non-visual classes that encapsulate the app's data. Therefore, the model can be thougth of as representing the app's domain model, which usually includes a data model along with business and validation logic. Examples of model objects include data transfer objects (DTOs), Plain Old CLR (POCOs), 
and generated entity and proxy objects.

Model classes are typically used in conjunction with services or repositories that encapsulate data acces and caching.

-----------------------

Modelo

Las clases del modelo son clases no visuales que encapsulan los datos de la aplicacion. por lo tanto, se puede pensar que el modelo representa el modelo de dominio de la aplicacion, que generalmente incluye un modelo de datos junto con la logica empresarial y de validacion. Algunos ejemplos de objetos de modelo
incluyen objetos de transferencia de datos (DTO), objetos CLR simples (POCO) y objetos proxy y de entidad generados.

Las clases de modelo generalmente se utilizan junto con servicios o repositorios que encapsulan el acceso a los datos y el almacenamiento en cache.

-------------------------------

Connecting view models to views 

View models can be connected to views by using the data-binding capabilities of .NET MAUI. There are many approaches that can be used to construct views and view models and associate them a runtime. Theses approaches fall into two categories, 


